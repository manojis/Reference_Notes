Java:-
====================================================

Java 8, only multiple inheritances of type and behavior is supported in Java (by introducing default methods in Java 8), but multiple inheritances of the state is still not supported.
HashMap: Hashmap can have one null key and multiple null values.The null key is handled specially in HashMap, there are two separate methods for that putForNullKey(V value) and getForNullKey(). Later is offloaded version of get() to look up null keys.  Null keys always map to index 0


Instance variable and a class variable:-
An instance variable is a variable which has one copy per object / instance. That means every object will have one copy of it.A class variable is a variable which has one copy per class. The class variables will not have a copy in the object.

ClassNotFoundException and NoClassDefFoundError:-
Both occur when a particular class is not found at runtime. However, they occur at different scenarios.
ClassNotFoundException is an exception that occurs when you try to load a class at run time using Class.forName() or loadClass() methods and mentioned classes are not found in the classpath.
NoClassDefFoundError is an error that occurs when a particular class is present at compile time, but was missing at run time.
ClassNotFoundException is a runtime exception that is thrown when an application tries to load a class at runtime using the Class.forName() or loadClass() or findSystemClass() methods ,and the class with specified name are not found in the classpath. Example:- connect to MySQL or Oracle databases and you have not updated the classpath with required JAR files. Most of the time, this exception occurs when you try to run an application without updating the classpath with required JAR files like "oracle.jdbc.driver.OracleDriver” is not found in the classpath.
NoClassDefFoundError is an error that is thrown when the Java Runtime System tries to load the definition of a class, and that class definition is no longer available. The required class definition was present at compile time, but it was missing at runtime.Example: can be created by removing one of the .class file which is accessed by another class.


Basic Authentication HTTP request could be make through a generic JAX-RS REST client just by appending a HTTP header info into the request.

public void testBasicAuthentication() {
    //Define basic authentication credential values
    String username = "myusername";
    String password = "myPassword";

    String usernameAndPassword = username + ":" + password;
    String authorizationHeaderName = "Authorization";
    String authorizationHeaderValue = "Basic " + java.util.Base64.getEncoder().encodeToString( usernameAndPassword.getBytes() );

    // Build the form for a post request
    MultivaluedMap&lt; String, String&gt; formParameters = new MultivaluedHashMap();
    formParameters.add( "field1", "fieldValue1" );
    formParameters.add( "field2", "fieldValue2" );

    // Perform a post request
    String restResource = "https://restserver:8080/app-name/rest-api/";
    Client client = ClientBuilder.newClient();
    Response res = client.target(restResource)
        .path( "login" ) // API Module Path
        .request( "application/json" ) // Expected response mime type
        .header( authorizationHeaderName, authorizationHeaderValue ) // The basic authentication header goes here
        .post( Entity.form( formParameters ) );     // Perform a post with the form values
    assertTrue( res.getStatus() == 200 );
}
============================================================================================
RMI:-
Stub Object(Client Server):-
The stub object on the client machine builds an information block and sends this information to the server. The block consists of
An identifier of the remote object to be used
Method name which is to be invoked
Parameters to the remote JVM

Sekeleton Object(Remote Server):-
The skeleton object passes the request from the stub object to the remote object. It performs following tasks
It calls the desired method on the real object present on the server.
It forwards the parameters received from the stub object to the method.


Checked exceptions are subclasses of Exception and Unchecked exceptions are subclasses of RuntimeException, RuntimeException itself is a subclass of Exception.
===========================================================================================
Double Checked locking pattern: To reduce the overhead of locking in threaded environment , we first check for the locking criterion without actually acquiring the lock , and once confirmed that locking is required, we proceed with the actual locking.
// Single-threaded version
class Foo {
    private Helper helper;
    public Helper getHelper() {
        if (helper == null) {
            helper = new Helper();
        }
        return helper;
    }
    // other functions and members...
}
The problem is that this does not work when using multiple threads. A lock must be obtained in case two threads call getHelper() simultaneously. Otherwise, either they may both try to create the object at the same time, or one may wind up getting a reference to an incompletely initialized object.
The lock is obtained by expensive synchronizing.
/ Correct but possibly expensive multithreaded version
class Foo {
    private Helper helper;
    public synchronized Helper getHelper() {
        if (helper == null) {
            helper = new Helper();
        }
        return helper;
    }
    // other functions and members...
}
However, the first call to getHelper() will create the object and only the few threads trying to access it during that time need to be synchronized; after that all calls just get a reference to the member variable. Since synchronizing a method could in some extreme cases decrease performance by a factor of 100 or higher,[5] the overhead of acquiring and releasing a lock every time this method is called seems unnecessary: once the initialization has been completed, acquiring and releasing the locks would appear unnecessary. Many programmers have attempted to optimize this situation in the following manner:

Check that the variable is initialized (without obtaining the lock). If it is initialized, return it immediately.
Obtain the lock.
Double-check whether the variable has already been initialized: if another thread acquired the lock first, it may have already done the initialization. If so, return the initialized variable.
Otherwise, initialize and return the variable.
// Broken multithreaded version
// "Double-Checked Locking" idiom
class Foo {
    private Helper helper;
    public Helper getHelper() {
        if (helper == null) {
            synchronized(this) {
                if (helper == null) {
                    helper = new Helper();
                }
            }
        }
        return helper;
    }

    // other functions and members...
}
Intuitively, this algorithm seems like an efficient solution to the problem. However, this technique has many subtle problems and should usually be avoided. For example, consider the following sequence of events:

Thread A notices that the value is not initialized, so it obtains the lock and begins to initialize the value.
Due to the semantics of some programming languages, the code generated by the compiler is allowed to update the shared variable to point to a partially constructed object before A has finished performing the initialization. For example, in Java if a call to a constructor has been inlined then the shared variable may immediately be updated once the storage has been allocated but before the inlined constructor initializes the object.[6]
Thread B notices that the shared variable has been initialized (or so it appears), and returns its value. Because thread B believes the value is already initialized, it does not acquire the lock. If B uses the object before all of the initialization done by A is seen by B (either because A has not finished initializing it or because some of the initialized values in the object have not yet percolated to the memory B uses (cache coherence)), the program will likely crash.

As of J2SE 5.0, this problem has been fixed. The volatile keyword now ensures that multiple threads handle the singleton instance correctly.
// Works with acquire/release semantics for volatile in Java 1.5 and later
// Broken under Java 1.4 and earlier semantics for volatile
class Foo {
    private volatile Helper helper;
    public Helper getHelper() {
        Helper result = helper;
        if (result == null) {
            synchronized(this) {
                result = helper;
                if (result == null) {
                    helper = result = new Helper();
                }
            }
        }
        return result;
    }
    // other functions and members...
}
============================================
Heap vs stack:-
Java only stores primitives on the stack. This keeps the stack small and helps keeping individual stack frames small, thus allowing more nested calls.
Objects are created on the heap, and only references (which in turn are primitives) are passed around on the stack.

Threads:-
=========
start() method of java.lang.Thread

When a CPU switches from executing one thread to executing another, the CPU needs to save the local data, program pointer etc. of the current thread, and load the local data, program pointer etc. of the next thread to execute. This switch is called a "context switch".
Concurrency - java.util.concurrent
Object - java.lang.Object
Persistent Data structure
if multiple threads point to the same persistent data structure and one thread modifies it, the modifying thread gets a reference to the new structure. All other threads keep a reference to the old structure which is still unchanged and thus consistent.
Actors vs channels:-
Workers are the actors and they can communicate with each other as messages in Actor model
In Channel model, the workers talk to each other through channels. They try to broadcast the message via channels
Same Threaded system: Data is not shared among the threads. Each thread has its own piece of data which is opposite to Multi Threaded system.

Thread communication happens by one of the Thread generates a message, which is copied by another thread which wants to read that message. The copying is done to ensure that the message is not updatable during read operation by Thread B.
Implementing Runnable is better than extending a thread, and handing an instance of the implementation to a Thread instance. When having the Runnable's executed by a thread pool it is easy to queue up the Runnable instances until a thread from the pool is idle.
Thread.currentThread() - The Thread.currentThread() method returns a reference to the Thread instance executing currentThread() . This way you can get access to the Java Thread object representing the thread executing a given block of code.

In a multithreaded environment,ArrayList and HashMap are not synchronized, while Vector and HashTable are. You should therefore use HashTable. HashTable will ensure that no other thread is working with the HashTable at any given time. If you use a HashMap, you'd have to do that manually by ensuring that you synchronize on HashMap before you call the method or Collections.synchronizedMap(new HashMap()).

Extends Thread or Implements Thread is better:-
extend Thread only when you are looking to modify run() and other methods as well. If you are simply looking to modify only the run() method implementing Runnable is the best option (Runnable interface has only one abstract method i.e. run() )

Race condition:-
affects the critical section of the system, which is the part of the logic where multiple thread can share the same object and can make an impact on the value of the object or the logic.Solution for the Race condition is to handle the critical section as an atomic instruction, so that only one thread is executing the block of code at a time.
Solution for Race condition: Using Synchronized block of code, locks, atomic variables(java.util.concurrent.atomic.AtomicInteger).

Local Objects and Local References to Object act differently in a thread.Here the reference is not shared but the referenced object is stored in heap and shared among threads.
Local Object- Thread safe
Local object reference - NO thread safe
Object member variable - Not Thread safe

All the class member variables and the object created by the threads are stored in the heap, including the object references(ocal variable may also be a reference to an object).In that case the reference (the local variable) is stored on the thread stack, but the object itself if stored on the heap.
Static class variables are also stored on the heap along with the class definition.

object lock and class lock:-
============================
Synchronized:-if more than one instance exist, then one thread at a time can execute inside a synchronized instance method per instance.
Static Synchronized: Synchronized static methods are synchronized on the class object of the class the synchronized static method belongs to. Since only one class object exists in the Java VM per class, only one thread can execute inside a static synchronized method in the same class.

volatile keyword: -

Wait(), Notify(), NotifyAll()- Tells about how threads communicate between each other.
=============================
A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object.In order to call either wait() or notify the calling thread must first obtain the lock on that object. In other words, the calling thread must call wait() or notify() from inside a synchronized block.
The waiting thread would call doWait(), and the notifying thread would call doNotify(). When a thread calls notify() on an object, one of the threads waiting on that object are awakened and allowed to execute. There is also a notifyAll() method that will wake all threads waiting on a given object.both the waiting and notifying thread calls wait() and notify() from within a synchronized block. A thread cannot call wait(), notify() or notifyAll() without holding the lock on the object the method is called on. If it does, an IllegalMonitorStateException is thrown.
Once a thread calls wait() it releases the lock it holds on the monitor object. This allows other threads to call wait() or notify() too, since these methods must be called from inside a synchronized block.
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block. In other words: The awakened thread must re-obtain the lock on the monitor object before it can exit the wait() call, because the wait call is nested inside a synchronized block. If multiple threads are awakened using notifyAll() only one awakened thread at a time can exit the wait() method, since each thread must obtain the lock on the monitor object in turn before exiting wait().

1).Every object created in Java has one associated monitor (mutually exclusive lock). Only one thread can own a monitor at any given time.
2).For achieving synchronization in Java this monitor is used. When any thread enters a synchronized method/block it acquires the lock on the specified object. When any thread acquires a lock it is said to have entered the monitor. All other threads which need to execute the same shared piece of code (locked monitor) will be suspended until the thread which initially acquired the lock releases it.
3).wait method tells the current thread (thread which is executing code inside a synchronized method or block) to give up monitor and go to waiting state.
4).notify method wakes up a single thread that is waiting on this object's monitor.
5).notifyAll method wakes up all the threads that called wait() on the same object.
    Any method or a block of code, if not qualified with the keyword synchronized can be executed by more than one thread at any given time as object's monitor(lock) is not in the picture. Where as when a method is synchronized (or there is a synchronized block) only a single thread who has acquired the object's monitor can access the code.Since wait() method is about thread releasing the object's lock and go to sleep where as notify/notifyAll methods are about notifying the thread(s) waiting for the object's lock. So, wait(), notify() and notifyAll() methods (as mentioned above) should be invoked on an object only when the current thread has already acquired the lock on an object. In fact not doing so will result in java.lang.IllegalMonitorStateException.

sleep():
	It is a static method on Thread class. It makes the current thread into the "Not Runnable" state for specified amount of time. During this time, the thread keeps the lock (monitors) it has acquired.

wait():
	It is a method on Object class. It makes the current thread into the "Not Runnable"	state. Wait is called on a object, not a thread. Before calling wait() method, the
	object should be synchronized, means the object should be inside synchronized block.	The call to wait() releases the acquired lock.
Suspend(), resume() and Destroy() has been deprecated.

Deadlock prevention:-
1). Lock ordering
2). Lock TimeOut
3). Deadlock Detection and then do lock timeout or assign priority to threads.

Starvation in Java:-
===================
Threads with high priority swallow all CPU time from threads with lower priority.
Threads are blocked indefinitely waiting to enter a synchronized block, because other threads are constantly allowed access before it.
Threads waiting on an object (called wait() on it) remain waiting indefinitely because other threads are constantly awakened instead of it.

use join() method to ensure all threads that started from main must end in order in which they started and also main should end in last.In other words waits for this thread to die. Calling join() method internally calls join(0);

ThreadLocal is a class which provides thread-local variables. Every thread has its own ThreadLocal value that makes ThreadLocal value threadsafe as well.
ThreadLocal is a generic class and can be used to store information like start timestamp of thread in that variable. Each thread has no visibility of the other thread.
Thread Dumps: analyzing threads performance, thread states, CPU consumed by threads, garbage collection including which all threads are daemon and not daemon.
Since values set on a ThreadLocal object only are visible to the thread who set the value, no thread can set an initial value on a ThreadLocal using set() which is visible to all threads.Instead you can specify an initial value for a ThreadLocal object by subclassing ThreadLocal and overriding the initialValue() method.

private ThreadLocal myThreadLocal = new ThreadLocal<String>() {
    @Override protected String initialValue() {
        return "This is the initial value";
    }
};
when program starts JVM creates  a ThreadGroup named main. Unless specified, all  newly created threads become members of the main thread group.ThreadGroup is initialized with default priority of 10.

Total JVM Memory --> Heap Memory + Non Heap
================
Heap Memory ---> Young Generation and Old Generation
Young Generation --> Eden And Survivor Space
Old Generation --> Tenured

Non Heap memory --> Perm Gen + reserved or virtual memory
permGen --> memory where metadat info of class and object is provided. replaced by metspace in java 8(flexible memory). Moved to native memory
Heap Memory java:
================
Heap is the primary storage inside JVM for storing the runtime data that are accessed by the multiple threads. Heap memory is the common for all the threads, the data stored in the heap is accessible to all the threads running on JVM.

Concurrency models:
Actors vs channels
Parallel vs Assembly line vs functional parallelism
Functional Parallelism: The basic idea of functional parallelism is that you implement your program using function calls. Functions can be seen as "agents" or "actors" that send messages to each other, just like in the assembly line concurrency model (AKA reactive or event driven systems). When one function calls another, that is similar to sending a message.
All parameters passed to the function are copied and then processing is done, hence there is no shared state which will lead to race conditions or any entity outside will be able to manipulate the data.All process works independently like the Atomic operation, where unit of works happens independently. This helps in executing each task written based on functional parallelism to be executed on different cpu's.
Functional parallelism : forkandjoinpool in java7 and Streams in java 8.

Single threaded vs multithreaded vs same threaded systems(messages are passed b/w the threads accessing different data)

Executor vs Thread:
==================
First and foremost difference between Thread and Executor is that java.lang.Thread is a class in Java while java.util.concurrent.Executor is an interface.
The Executor concept is actually an abstraction over parallel computation. It allows concurrent code to be run in managed way. On the other hand, Thread is a concrete way to run the code in parallel.
The third difference between an Executor and a Thread class is that former decouples a task (the code which needs to be executed in parallel) from execution, while in the case of a Thread, both task and execution are tightly coupled.
The Executor concept allows your task to be executed by a worker thread from the thread pool, while Thread itself execute your task.
The Executor concept allows your task is to be executed by a worker thread from the thread pool, while Thread itself execute your task.
Executor provides a execute() method which accepts a Runnable task, while Thread accepts the Runnable task on its constructor.
One more key difference between a Thread and an Executor is that a Thread can only execute one Runnable task but an Executor can execute any number of Runnable task.
In the case of Thread, the task is executed by the Thread which accepts Runnable instance, but in the case of Execution the command (a Runnable implementation) may be executed in a new thread, a pooled thread or in the calling thread itself, depending upon the implementation of Executor interface.
In the case of a thread, it's developer's responsibility to create and start the thread, but in the case of Executor, the framework will create and start threads for you. Though you can control the whole process by giving your implementation of Executor interface. Though, with the improvements in ForkJoinPool in Java 7 and 8, you might want to use that instead of Executor.

Sleep vs yield in Java:-
=======================
Sleep and yield are two methods which are used to get CPU back from Thread to Thread Scheduler in java but they are completely different than each other. The major difference between Sleep vs yield is that sleep is more reliable than yield and it's advised to use sleep(1) instead of yield to relinquish CPU in multi-threaded Java application to give an opportunity to other threads to execute.
Both sleep() and yield() are static methods and operate on current thread
Thread.sleep() method throws InterruptedExcepiton if another thread interrupt the sleeping thread, this is not the case with yiedl method.
Thread.sleep() method doesn't cause currently executing thread to give up any monitors while sleeping.
sleep() method is to pause the current thread, but it will not release any lock held by current thread. If you also want thread to release CPU as well as any lock held, consider using wait() method instead.

the Executor framework is that you can run concurrent tasks that may return a result after processing the task. The Java Concurrency API achieves this with the following two interfaces Callable and Future.
Callable : This interface has the call() method. In this method, you have to implement the logic of a task. The Callable interface is a parameterized interface, meaning you have to indicate the type of data the call() method will return.
Future : This interface has some methods to obtain the result generated by a Callable object and to manage its state.

Executor.submit() and Executor.execute():-
==============================
A main difference between the submit() and execute() method is that ExecuterService.submit() can return result of computation because it has a return type of Future, but execute() method cannot return anything because it's return type is void.
The submit() can accept both Runnable and Callable task but execute() can only accept the Runnable task.It Returns a future task on calling submit().
The submit() method is declared in ExecutorService interface while execute() method is declared in the Executor interface.

creating a thread in java leads to lot of memory overhead and hence better to reuse threads from threadpool.
Executor vs Thread: Executor service offers all the implementations of the Runnable interface, on top of that call() which is overridden can provide any object as return type alongwith exception where ever needed.

Executor interface has to create a threadpool using ExecutorService.newFixedThreadPool(size in integers).Use this executor to submit the task which is callable

      ExecutorService service = Executors.newFixedThreadPool(10);
      List<MyCallable> futureList = new ArrayList<MyCallable>();
      for ( int i=0; i<12; i++){
          MyCallable myCallable = new MyCallable((long)i);
          futureList.add(myCallable);
      }
Callable needs to implement call() method while a Runnable needs to implement run() method.
A Callable can return a value but a Runnable cannot.
A Callable can throw checked exception but a Runnable cannot.
A Callable can be used with ExecutorService#invokeXXX(Collection<? extends Callable<T>> tasks) methods but a Runnable cannot be.

Callable vs Runnable:-
=====================
Both Callable and Runnable interface are used to encapsulate task supposed to be executed by another thread
Callable can return result
Callable can throw checked exception.

ExecutorService -> can use both Callable and Runnable(Submit() can accept both)
Executor -> Only Runnable(i.e execute() can only accept Runnable).

Callable can return the result of parallel processing of a task. It returns a Future object, which represents the lifecycle of a task and provides methods to check if the task has been completed or canceled, retrieve the result or cancel the task. Since return type of Runnable's run() method is void, it cannot return anything.

RejectedExecutionHandler would be useful when you set max capacity for workQueue and number of tasks, which have been submitted to Executor are more than workQueue capacity.

Locks:-
with locks, you can release and acquire the locks in any order. - with synchronized, you can release the locks only in the order it was acquired.
Lock lock = new Lock();
lock.lock();
lock.unlock();
The lock() method locks the Lock instance so that all threads calling lock() are blocked until unlock() is executed.

Deadlock vs Nested Monitor Lockout:-
===================================
In deadlock, two threads are waiting for each other to release locks.In nested monitor lockout, Thread 1 is holding a lock A, and waits for a signal from Thread 2. Thread 2 needs the lock A to send the signal to Thread 1.

Slipped condition:
Slipped conditions means, that from the time a thread has checked a certain condition until it acts upon it, the condition has been changed by another thread so that it is erroneous for the first thread to act.

CyclicBarrier and CountDownLatch:-
==================================
Both CyclicBarrier and CountDownLatch are used to implement a scenario where one Thread waits for one or more Thread to complete there job before starts processing but there is one Difference between CountDownLatch and CyclicBarrier in Java which separates them apart and that is, you can not reuse same CountDownLatch instance once count reaches to zero and latch is open, on the other hand CyclicBarrier can be reused by resetting Barrier, Once barrier is broken

Missed signals:-
===============
 if a thread calls notify() before the thread to signal has called wait(), the signal will be missed by the waiting thread. In some cases this may result in the waiting thread waiting forever, never waking up, because the signal to wake up was missed.
countdownlatch:-
===============
A java.util.concurrent.CountDownLatch is a concurrency construct that allows one or more threads to wait for a given set of operations to complete.
cyclicBarrier:
==============
it is a barrier that all threads must wait at, until all threads reach it, before any of the threads can continue. 
Semaphores:
===========
A Semaphore is a thread synchronization construct that can be used either to send signals between threads to avoid missed signals, or to guard a critical section like you would with a lock.

Lock Re-Entrance:
================
Synchronized blocks in Java are reentrant. This means, that if a Java thread enters a synchronized block of code, and thereby take the lock on the monitor object the block is synchronized on, the thread can enter other Java code blocks synchronized on the same monitor object.
If a thread already holds the lock on a monitor object, it has access to all blocks synchronized on the same monitor object. This is called reentrance. The thread can reenter any block of code for which it already holds the lock.Also, we need to ensure that lock count is taken to ensure this during unlock() as well, so that even if the lock has been locked multiple times. We don't want the lock to be unlocked until the thread that locked it, has executed the same amount of unlock() calls as lock() calls.
java synchronized keyword is re-entrant in nature it means if a java synchronized method calls another synchronized method which requires same lock then current thread which is holding lock can enter into that method without acquiring lock.
-->When guarding a critical section with a Lock, and the critical section may throw exceptions, it is important to call the unlock() method from inside a finally-clause. Doing so makes sure that the Lock is unlocked so other threads can lock it.

Object level locking vs class level locking:-
===========================================
Object level locking is mechanism when you want to synchronize a non-static method or non-static code block such that only one thread will be able to execute the code block on given instance of the class. This should always be done to make instance level data thread safe.
Class level locking prevents multiple threads to enter in synchronized block in any of all available instances on runtime. This means if in runtime there are 100 instances of  DemoClass, then only one thread will be able to execute demoMethod() in any one of instance at a time, and all other instances will be locked for other threads.


Threads:
Runnable
Future
Callable
run()
call()
Executor
Executors
ExecutorService
ThreadPoolExecutor
CountDownLatch
Queues & Topics
ForkJoinPool
Streams


web.xml

For a Java servlet to be accessible from a browser, we must tell the servlet container what servlets to deploy, and what URL's to map the servlets to. This is done in the web.xml file of your Java web application. It informs the Web/Servlet container where to look for the servlet, its respective servlet-mapping, filters and any needed additional one-time configurations.

In a Spring based application, we are concerned with primarily the DispatcherServlet, that dispatches requests to the handlers, which further redirects the request to the appropriate controller method based on the handler mappings.

web.xml basically acts as the Superset for all your app config files.

What is a context in Java?

A context can be said as the running environment that is provided to the current unit of work. It may be the environment variables, instance variables, state of the classes, and so on.
Like ServletContext represents the servlet’s environment within its container, Similar to ApplicationContext, which represents the Spring application’s core environment within the Spring container.
There are Servlet’s ServletContext, JSF’s FacesContext, Spring’s ApplicationContext, JNDI’s InitialContext, and all these contexts follow the Facade Pattern to Abstract the environment specific details to the end user, providing the interface methods to Interact with.
In Spring web applications, there are two contexts that gets initialized at server startup, each of which is configured and initialized differently.
Application Context
Web Application Context

What is ApplicationContext ?

ApplicationContext defines the beans that are shared among all the servlets.
In ApplicationContext, Spring loads applicationContext.xml file and creates the context for the whole application using ContextLoaderListener that we define in our application’s web.xml.
applicationContext.xml is the root context configuration for every web application There will be only one application context per web application.
If you are not explicitly declaring the context configuration file name in web.xml using the contextConfigLocation param, Spring will search for the applicationContext.xml under WEB-INF folder and throw FileNotFoundException, if it could not find this file.
Beans that defines your business logic, database interaction and other stuff that has to be shared across servlets should reside in applicationContext.xml.
Ex - This is the part of web.xml file

<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/root-context.xml</param-value>
</context-param>
In the above configuration, we are asking Spring to load root-context.xml and create an Application Context from it.

If contextConfigLocation is not mentioned as in the above snippet, It will by default look for /WEB-INF/applicationContext.xml

At server startup ContextLoaderListener instantiates all bean defined in applicationcontext.xml assuming you have defined the following in context xml file :

<import resource="test1.xml" />
<import resource="test2.xml" />
<import resource="test3.xml" />
<import resource="test4.xml" />
The beans are instantiated from all four configuration files test1.xml, test2.xml, test3.xml, test4.xml.

What is WebApplicationContext ?

There can be multiple WebApplicationContext in a single web application.
It is another servlet specific context that is loaded based on the dispatcher servlets configured in the application’s web.xml file.
Each dispatcher servlet has its own servlet-context initialized from -servlet.xml file.
This allows us to categorize the incoming requests based on the servlet’s url-pattern and handle them accordingly, such that one of dispatcher servlets could help serving the web pages via Controller, while another one could be used to implement a stateless REST web service.
We understand that a single web application can have multiple dispatcher-servlet configurations.
dispatcher-servlet.xml defines the beans that are related only to that servlet. Beans that deals with servlet requests / web requests like controllers, message converters, interceptors should reside in dispatcher-servlet xml.
Ex - If we want to change the name of the dispatcher-servlet file name or change its location, we can add init-param with contextConfigLocation as param-name, as can be seen below

<servlet>
    <servlet-name>spring</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/spring-servlet.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>spring</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
So with spring-servlet init-param specified as in the above web.xml code snippet, Spring no more finds the dispatcher-servlet context file with the name spring-servlet.xml, but instead looks for the one specified as the init-param value for contextConfigLocation, i.e. spring-servlet.xml.

Object creations workflow

When tomcat starts, beans defined in dispatcher-servlet.xml are instantiated.
DispatcherServlet extends FrameworkServlet. In FrameworkServlet bean instantiation takes place for dispatcher. In our case dispatcher is FrameworkServlet.
The beans are all instantiated from all four test1.xml, test2.xml, test3.xml, test4.xml. After the completion of bean instantiation defined in applicationcontext.xml then beans defined in dispatcher-servlet.xml are instantiated.
Instantiation order is root is application context, then FrameworkServlet.
Difference between the two contexts

ApplicationContext is the root-context that has bean configurations we might want to use (and re-use) across the entire application as singletons.
There can be multiple WebApplicationContexts for each of the dispatcher servlets we specify in our application’s web.xml.
WebApplicationContext internally extends ApplicationContext, and as a child inherits all the beans from its parent. So we can also override the parent bean within our WebApplicationContext.
It’s always better to keep a clear separation between middle-tier services such as business logic components and data access classes (which we prefer defining in the ApplicationContext XML), and web-related components such as controllers and view-resolvers (which we prefer defining in the respective dispatcher-servlet‘s WebApplicationContext).
Configuring contextLoaderListener is completely optional. We can boot up a Spring application with just the dispatcher-servlet, without even configuring contextLoaderListener (that loads up the root-context).


applicationContext.xml defines the beans that are shared among all the servlets. If your application have more than one servlet, then defining the common resources in the applicationContext.xml would make more sense.

spring-servlet.xml defines the beans that are related only to that servlet. Here it is the dispatcher servlet. So, your Spring MVC controllers must be defined in this file.

There is nothing wrong in defining all the beans in the spring-servlet.xml if you are running only one servlet in your web application.

Scenario 1

In client application (application is not web application, e.g may be swing app)

private static ApplicationContext context = new  ClassPathXmlApplicationContext("test-client.xml");

context.getBean(name);
No need of web.xml. ApplicationContext as container for getting bean service. No need for web server container. In test-client.xml there can be Simple bean with no remoting, bean with remoting.

Conclusion: In Scenario 1 applicationContext and DispatcherServlet are not related.

Scenario 2

In a server application (application deployed in server e.g Tomcat). Accessed service via remoting from client program (e.g swing app)

Define listener in web.xml

<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
At server startup ContextLoaderListener instantiates beans defined in applicationcontext.xml.

Assuming you have defined the following in applicationcontext.xml:

<import resource="test1.xml" />
<import resource="test2.xml" />
<import resource="test3.xml" />
<import resource="test4.xml" />
The beans are instantiated from all four configuration files test1.xml, test2.xml, test3.xml, test4.xml.

Conclusion: In Scenario 2 applicationContext and DispatcherServlet are not related.

Scenario 3

In a web application with spring MVC.

In web.xml define:

<servlet>
    <servlet-name>springweb</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>    
</servlet>

<servlet-mapping>
    <servlet-name>springweb</servlet-name>
    <url-pattern>*.action</url-pattern>
</servlet-mapping>
When tomcat starts, beans defined in springweb-servlet.xml are instantiated. DispatcherServlet extends FrameworkServlet. In FrameworkServlet bean instantiation takes place for springweb . In our case springweb is FrameworkServlet.

Conclusion: In Scenario 3 applicationContext and DispatcherServlet are not related.

Scenario 4

In web application with spring MVC. springweb-servlet.xml for servlet and applicationcontext.xml for accessing the business service within the server program or for accessing DB service in another server program.

In web.xml the following are defined:

<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

<servlet>
    <servlet-name>springweb</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

</servlet>

<servlet-mapping>
    <servlet-name>springweb</servlet-name>
    <url-pattern>*.action</url-pattern>
</servlet-mapping>
At server startup, ContextLoaderListener instantiates beans defined in applicationcontext.xml; assuming you have declared herein:

<import resource="test1.xml" />
<import resource="test2.xml" />
<import resource="test3.xml" />
<import resource="test4.xml" />
The beans are all instantiated from all four test1.xml, test2.xml, test3.xml, test4.xml. After the completion of bean instantiation defined in applicationcontext.xml then beans defined in springweb-servlet.xml are instantiated.

So instantiation order is root is application context, then FrameworkServlet.
=============================================
web.xml: This file is part of the servlet specification. It tells the container (eg.Tomcat, your app runs on top of one) mainly where to look for Components like ServletFilters, Servlets (they do the actual work) and some configuration that you don't need to use any more. We are using it because its the only way to implement a JAVA Web Application. Most of the time, we only specify the DispatcherServlet and that could be it for web.xml.

applicationContext.xml: This file is the standard Spring Context (will explain later) that defines Services and Components of your application. It will contain most of your Dependency Injection definition and a bit of configuration (imagine it like "assembly instructions" for the Classes you wrote). In a webapp scenario, you can but don't need to have it. In fact I would not use it but use imports in the contexts as this is easier to manage. It is also not loaded by default in a webapp scenario and would require a ContextLoaderListener to be found.

spring-servlet.xml: The file is called this way, because you mapped the DispatcherServlet in web.xml with the servlet-name "servlet". This is by convention. This file is the entry point for Spring, when the DispatcherServlet is loaded it finds this file and starts to load its components. You could place all your services there too and have only this single xml apart from the web.xml. Nevertheless, for unit testing purposes I would advise you to create a services.xml next to it and import it which will only contain all beans that you want to write tests against. This way you can run something for testing purposes without a webapp container.

Now, finally, context, what is it? Back in the days people were writing the Singleton Pattern all over the place and it was hard to manage. The idea of Spring was (simplified) to have a central "registry" that takes care of the assembly of the application, by looking at a definition of what everyone needs and then handing out these References. The term "context" is because it is the context of the application.	
=============================================
web.xml (deployment desciptor):  this file gets loaded on an application/web server startup (Tomcat, JBOSS etc) and it informs the Web/Servlet container about the servlet / filter classes config used <servlet>(dispatcher-servlet.xml / spring-servlet.xml loc inform goes here)</servlet>. <load-on-startup> tells the servlet container to load the specific servlet during the application startup itself ( early / eager instantiation ). If you require any information to be shared across all servlets / filters like JAAS , Spring Security, error-page you can mention it here. web.xml also tells about the Spring container class location (<listener>(applicationContext.xml  goes here)</listener>).<context-param> holds properties globally for all servlets which can be accessed using ServletContext & <init-param> holds properties for the specific servlet which can be accessed using ServletConfig objects inside your servlet classes. So basically web.xml acts as the Superset for all your app config files.

applicationContext.xml : this basically defines your Spring DI / IOC bean dependencies. Normally you will just import the xml config files here instead of specifying all the config information all at a single place to maintain better readability & access. the imports will include Hibernate.xml (datasource, sessionFactory, show_sql, schemaConstruction, mapping classes etc), DataSource.xml ( inturn can refer to datasource properties for multi-env using placeholders), Spring-beans.xml (bean DI's / <context:component-scan base-package=""/> if annotations are used with Autowiring).


dispatcher-servlet.xml : to handle web request / responses based on url patterns. Used only when Spring MVC framework is used. Contains information about the Handler Mapping , Controller, InternalResourceViewResolver etc.,


spring-servlet.xml : this is a kind of generic name used for the servlet specific config files (dispatcher-servlet.xml for Spring MVC, faces-config.xml for JSF) & will contain information specific to the particular kind of servlets been used.
=============================================
dispatcher-servlet.xml is the post office for the mail in Spring town, every letter should go through them, but some people keep on sending things with the old web.xml county office (which should be only an intermediary), which is a part of the country that was once great and independent, but now is just a district. May be old and not fancy, but it worked nicely when administered appropriately, some areas of the web.xml county have roads that lead to cliffs 404 meters in deep. 

applicationContext.xml is the town hall which is a little communist in that it should control all the incoming mail, but everyone knows that holes exist and you can do weird things, like sending mail to destinations in web.xml, those filty old servlets... 

spring-servlet.xml is the central office for nice citizen interaction, they don´t care about the guts of running a country, they just want billboards, TV programs, radio stations...

Usually the guts of the country are run at the hibernate.cfg.xml deposit placed in Persistenceland



BeanFactory
============
The BeanFactory is the actual container which instantiates, configures, and manages a number of beans. These beans typically collaborate with one another, and thus have dependencies between themselves. These dependencies are reflected in the configuration data used by the BeanFactory (although some dependencies may not be visible as configuration data, but rather be a function of programmatic interactions between beans at runtime).

ApplicationContext
===================
While the beans package provides basic functionality for managing and manipulating beans, often in a programmatic way, the context package adds ApplicationContext, which enhances BeanFactory functionality in a more framework-oriented style. Many users will use ApplicationContext in a completely declarative fashion, not even having to create it manually, but instead relying on support classes such as ContextLoader to automatically start an ApplicationContext as part of the normal startup process of a Java EE web-app. Of course, it is still possible to programmatically create an ApplicationContext.

The basis for the context package is the ApplicationContext interface, located in the org.springframework.context package. Deriving from the BeanFactory interface, it provides all the functionality of BeanFactory. To allow working in a more framework-oriented fashion, using layering and hierarchical contexts, the context package also provides the following:

MessageSource, providing access to messages in, i18n-style
Access to resources, such as URLs and files
Event propagation to beans implementing the ApplicationListener interface
Loading of multiple (hierarchical) contexts, allowing each to be focused on one particular layer, for example the web layer of an application
As the ApplicationContext includes all functionality of the BeanFactory, it is generally recommended that it be used over the BeanFactory, except for a few limited situations such as perhaps in an applet, where memory consumption might be critical, and a few extra kilobytes might make a difference. The following sections described functionality which ApplicationContext adds to basic BeanFactory capabilities.

==================================================================================================

Concurrency : Do you understand threads, deadlock, and starvation? What happens when multiple processes / threads are trying to modify the same data? A basic understanding of read and write locks.
-  Networking : Do you roughly understand basic networking protocols like TCP and UDP? Do you understand the role of switches and routers?
-  File systems : You should understand the systems you’re building upon. Do you know roughly how an OS, file system, and database work? Do you know about the various levels of caching in a modern OS?


The web.xml is a configuration file to describe how a web application should be deployed.Java web applications use a deployment descriptor file to determine how URLs map to servlets, which URLs require authentication, and other information. This file is named web.xml, and resides in the app's WAR under the WEB-INF/ directory. web.xml is part of the servlet standard for web applications.

From Servlet 3.0 onwards, Web.xml is optional, You can use @WebServlet annotation instead.
If you are using Spring, org.springframework.web.WebApplicationInitializer can be used instead or along with web.xml.

WebApplicationInitializer :
Interface to be implemented in Servlet 3.0+ environments in order to configure the ServletContext programmatically -- as opposed to (or possibly in conjunction with) the traditional web.xml-based approach.

If we dont use attribute tags in <web-app> inside the web.xml, then the one with attribute tags and without attribute tags is:-
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
 xmlns="http://java.sun.com/xml/ns/javaee" 
 xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" 
 version="3.0"></web-app>
 
The difference between them is that the web-app tag contains the attributes in the first one and the second one doesn't. The issue is if we apply the second web.xml we won't be able to use expressions like
${attrName}
in our jsp-pages. They won't be replaced with the corresponding values, added to a model in a Controller in the case of Spring MVC.
The first web.xml specifies the version of the Servlet API that the webapp requires (3.0), whereas the second one doesn't.
In the second case, the servlet container will take that to mean it was written for an older version of the Servlet API, specifically from a version of the Servlet API that didn't use the version attribute or strictly defined namespaces. Those older versions were pre-JSP-2.0, and so don't support the JSP expression language. That means your expressions won't be substituted (you wouldn't want older app that used that expression syntax for some other reason to suddenly have them evaluated by the container in a way that the author didn't intend).

For a modern webapp-you should always specify the Servlet API version you need.

================================================================================
Enable Spring auto component scanning features.
Annotate with @Component to indicate this is class is an auto scan component.
Put this “context:component” in bean configuration file, it means, enable auto scanning feature in Spring. The base-package is indicate where are your components stored, Spring will scan this folder and find out the bean (annotated with @Component) and register it in Spring container.
<context:component-scan base-package="com.mycompany.maventestwebapp" />
There are 4 types of auto components scan annotation types

@Component – Indicates a auto scan component.
@Repository – Indicates DAO component in the persistence layer.
@Service – Indicates a Service component in the business layer.
@Controller – Indicates a controller component in the presentation layer.

All @Repository,@Service or @Controller are annotated with @Component. So we can use @component for all components for auto scannning.
Spring will auto scan all your components with @Component annotated.
It’s works fine, but not a good practice, for readability, you should always declare @Repository,@Service or @Controller for a specified layer to make your code more easier to read.
================================================================================

<mvc:annotation-driven /> means that you can define spring beans dependencies without actually having to specify a bunch of elements in xml or implement an interface or extend a base class. For example @Repository to tell spring that a class is a Dao without having to extend JpaDaoSupport or some other subclass of DaoSupport. Similarly @Controller tells spring that the the class specified contains methods that will handle http requests without you having to implement the Controller interface or extend a subclass that implements controller.

When spring starts up it reads its xml configuration file and looks for <bean elements within it if it sees something like <bean class="com.example.Foo" /> and Foo was marked up with @Controller it knows that the class is a controller and treats it as such. By default spring assumes that all the classes it should manage are explicitly defined in the beans.xml file.

Component scanning with <context:component-scan base-package="com.mycompany.maventestwebapp" /> is telling spring that it should search the class path for all the classes under com.mycompany.maventestweapp and look at each class to see if it has a @Controller, or @Repository, or @Service, or @Component and if it does then Spring will register the class with the bean factory as if you had typed <bean class="..." /> in the xml configuration files.

In a typical spring mvc app you will find that there are two spring configuration files, a file that configures the application context, usually started with the spring context listener And a Spring MVC configuration file usually started with the Spring dispatcher servlet.
Common beans such as data sources, jpa configuration, business services are defined in the application context while MVC specific configuration goes not the configuration file associated with the servlet.

<context:component-scan base-package="" /> 
tells Spring to scan those packages for Annotations.

<mvc:annotation-driven> 
registers a RequestMappingHanderMapping, a RequestMappingHandlerAdapter, and an ExceptionHandlerExceptionResolver to support the annotated controller methods like @RequestMapping, @ExceptionHandler, etc. that come with MVC.This also enables a ConversionService that supports Annotation driven formatting of outputs as well as Annotation driven validation for inputs. It also enables support for @ResponseBody which you can use to return JSON data.

=================================================================================

Horizontal Scaling - also referred to as "scale-out" is basically the addition of more machines or setting up a cluster or a distributed environment for your software system. This usually requires a load-balancer program which is a middle-ware component in the standard 3 tier client-server architectural model. 

Load-Balancer is responsible to distribute user requests (load) among the various back-end systems/machines/nodes in the cluster. Each of these back-end machines run a copy of your software and hence capable of servicing requests. This is just one of the various functions that load balancer may be performing. Another very common responsibility is "health-check" where the load balancer uses the "ping-echo" protocol or exchanges heartbeat messages with all the servers to ensure they are up and running fine.

Load-Balancer distributes load by maintaining state of each machine -- how many requests are being served by each machine, which machine is idle, which machine is over-loaded with queued requests etc. So the load balancing algorithm considers such things before redirecting the request to an appropriate server machine. It also takes into account the network overhead and might choose the server in the nearest data-center provided it is available to service the requests. 

The request-response can also be done in 2 different ways:

1. Load Balancer always acts as an intermediary program for every response - In this case, once the request has been handed over to the server by the load balancer, any response from the server to the user will go through the load balancer. So the server machines that are actually servicing the request will never directly interface with the user machine running the client application. The machine hosting the load balancer program will be handling all the requests/responses to and from the user.

2. Load Balancer does not act as an intermediary for the responses coming from the server machine - In this case, once the server has received the request from load-balancer, it bypasses the load balancer and communicates it responses directly to the client. 

Setting up a cluster and load-balancer as a front-end interface to the client application does not really complete our scale-out architecture and design. There are still lots of critical questions to be answered and a number of key design decisions to be made which will affect the overall properties of our system.

We first need to identify our business goals and areas where we would like to add value. These goals will give rise to various requirements. We should then ask ourselves various questions with respect to different systemic properties.

1. Will such a design address our performance requirements ? 

2. What performance characteristics do we care about ? 
Is it the overall system throughput where we are interested in serving    maximum number of requests in any given time ?
Or is it the system's response time where we design for sending back      the response to client in as less time as possible ?
Both these and many other types of performance characteristics are related to each other.

3. Will such a design address our availability requirements ? Is the system fault-tolerant ? If so, what is the degree of it ?

4. Is such a design reliable ? Does it impact the correctness ? We should not forget that 100% correctness is an implicit goal of any system.

5. Are we really meeting our scalability goals ? Might be achieving the short-term or immediate ones, but what is going to happen in the long run ?

All these kinds of requirements should have quantifiable measures associated with them. 

We should then make important design decisions by questioning ourselves, developing prototypes, and refining the design.

1. Firstly, is using load-balancer the only approach to distribute load and horizontally scale the system ?

2. Do the various back-end servers or nodes communicate with each other ?
If yes, then how does the system address the situation where one or          more nodes go down -- permanently or temporarily ?
If yes, then how does the system address the situation where the       network connecting the nodes is down, but all the nodes are up and running ? Most importantly, do we have to differentiate between these two situations ? How ?
3. Whether or not the back-end nodes communicate with each other, does our system need to maintain consistent data across all the nodes ? What level of consistency do we care about ? Is it that
At any point in time, data across all the nodes should be consistent.
Or later some point in time, data across all the nodes will be consistent. If so, then what is this "later" ? When and how do all the nodes converge to a consistent state ? How will we achieve "total-order" of operations across all the nodes ? Do we have a global clock ? If we are relying on every node's local clock, then how do we synchronize the clocks of all machines. They can easily seem to regress or a machine with an out of order clock might join the cluster. As a consequence,  we may ignore the latest data, and consider old/stale data as the latest one.
4. What cluster setup do we have to design for ? 
Is it a "replica" cluster, where data on each node is replicated to some or every other node. In case of former, what is the replication factor, and how do we decide it ?
Or is it a sharded cluster where cluster is divided into various shards or units. A shard is a designated group of nodes. Each shard takes care of a particular partition of data. Data across shards is not replicated, but each shard can adopt replication strategy within itself.
Whatever distributed system we design, it should ideally be able to answer the above and many other similar questions. 

All this is what makes a distributed system so interesting and challenging to design and implement. 

Vertical Scaling -  also referred to as "scale-up" approach is an attempt to increase the capacity of a single machine :
By adding more processing power
By adding more storage
More memory etc
Summary:

What is important here is to understand the differences between these 2 scaling approaches, identify what suits our requirements, and see if the application really fits the model we choose.

As you would have understood by now, horizontal scaling comes with overhead in the form of cluster setup, management, and maintenance costs and complexities. The design gets increasingly complex and programming model changes. 

So simply throwing in new hardware and adding more nodes or machines is not the way to start. First, see if the requirements can be met by increasing the capacity or tuning characteristics of a single machine. If not, then go with the scale-out approach or a combination of both.
==============================================================================

Controller Based Exception Handling

Using @ExceptionHandler

You can add extra (@ExceptionHandler) methods to any controller to specifically handle exceptions thrown by request handling (@RequestMapping) methods in the same controller. Such methods can:

Handle exceptions without the @ResponseStatus annotation (typically predefined exceptions that you didn’t write)
Redirect the user to a dedicated error view
Build a totally custom error response
==================================================================================
http://stackoverflow.com/questions/15818047/spring-namespace-vs-contextconfiglocation-init-parameters-in-web-xml/15825207#15825207

http://stackoverflow.com/questions/7451325/spring-mvc-what-are-a-context-and-namespace/7451389#7451389

http://docs.spring.io/spring/docs/3.2.2.RELEASE/spring-framework-reference/html/beans.html#context-create

http://www.javaworld.com/article/2824163/application-performance/stability-patterns-applied-in-a-restful-architecture.html
http://www.baeldung.com/httpclient-connection-management

http://docs.spring.io/spring-data/cassandra/docs/2.0.0.M1/reference/html/
http://docs.spring.io/spring-data/cassandra/docs/1.0.2.RELEASE/reference/html/cassandra.core.html

http://www.baeldung.com/spring-data-cassandra-tutorial

https://examples.javacodegeeks.com/enterprise-java/spring/spring-data-cassandra-example/

http://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver
https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc
https://www.mkyong.com/spring-mvc/spring-mvc-exceptionhandler-example/
http://www.baeldung.com/exception-handling-for-rest-with-spring
