Java:-
====================================================

Java 8, only multiple inheritances of type and behavior is supported in Java (by introducing default methods in Java 8), but multiple inheritances of the state is still not supported.
HashMap: Hashmap can have one null key and multiple null values.The null key is handled specially in HashMap, there are two separate methods for that putForNullKey(V value) and getForNullKey(). Later is offloaded version of get() to look up null keys.  Null keys always map to index 0


Instance variable and a class variable:-
An instance variable is a variable which has one copy per object / instance. That means every object will have one copy of it.A class variable is a variable which has one copy per class. The class variables will not have a copy in the object.

ClassNotFoundException and NoClassDefFoundError:-
Both occur when a particular class is not found at runtime. However, they occur at different scenarios.
ClassNotFoundException is an exception that occurs when you try to load a class at run time using Class.forName() or loadClass() methods and mentioned classes are not found in the classpath.
NoClassDefFoundError is an error that occurs when a particular class is present at compile time, but was missing at run time.
ClassNotFoundException is a runtime exception that is thrown when an application tries to load a class at runtime using the Class.forName() or loadClass() or findSystemClass() methods ,and the class with specified name are not found in the classpath. Example:- onnect to MySQL or Oracle databases and you have not updated the classpath with required JAR files. Most of the time, this exception occurs when you try to run an application without updating the classpath with required JAR files like "oracle.jdbc.driver.OracleDriver‚Äù is not found in the classpath.
NoClassDefFoundError is an error that is thrown when the Java Runtime System tries to load the definition of a class, and that class definition is no longer available. The required class definition was present at compile time, but it was missing at runtime.Example: can be created by removing one of the .class file which is accessed by another class.


Basic Authentication HTTP request could be make through a generic JAX-RS REST client just by appending a HTTP header info into the request.

public void testBasicAuthentication() {
    //Define basic authentication credential values
    String username = "myusername";
    String password = "myPassword";

    String usernameAndPassword = username + ":" + password;
    String authorizationHeaderName = "Authorization";
    String authorizationHeaderValue = "Basic " + java.util.Base64.getEncoder().encodeToString( usernameAndPassword.getBytes() );

    // Build the form for a post request
    MultivaluedMap&lt; String, String&gt; formParameters = new MultivaluedHashMap();
    formParameters.add( "field1", "fieldValue1" );
    formParameters.add( "field2", "fieldValue2" );

    // Perform a post request
    String restResource = "https://restserver:8080/app-name/rest-api/";
    Client client = ClientBuilder.newClient();
    Response res = client.target(restResource)
        .path( "login" ) // API Module Path
        .request( "application/json" ) // Expected response mime type
        .header( authorizationHeaderName, authorizationHeaderValue ) // The basic authentication header goes here
        .post( Entity.form( formParameters ) );     // Perform a post with the form values
    assertTrue( res.getStatus() == 200 );
}
============================================================================================
RMI:-
Stub Object(Client Server):-
The stub object on the client machine builds an information block and sends this information to the server. The block consists of
An identifier of the remote object to be used
Method name which is to be invoked
Parameters to the remote JVM

Sekeleton Object(Remote Server):-
The skeleton object passes the request from the stub object to the remote object. It performs following tasks
It calls the desired method on the real object present on the server.
It forwards the parameters received from the stub object to the method.


Checked exceptions are subclasses of Exception and Unchecked exceptions are subclasses of RuntimeException, RuntimeException itself is a subclass of Exception.
===========================================================================================
Double Checked locking pattern: To reduce the overhead of locking in threaded environment , we first check for the locking criterion without actually acquiring the lock , and once confirmed that locking is required, we proceed with the actual locking.
// Single-threaded version
class Foo {
    private Helper helper;
    public Helper getHelper() {
        if (helper == null) {
            helper = new Helper();
        }
        return helper;
    }
    // other functions and members...
}
The problem is that this does not work when using multiple threads. A lock must be obtained in case two threads call getHelper() simultaneously. Otherwise, either they may both try to create the object at the same time, or one may wind up getting a reference to an incompletely initialized object.
The lock is obtained by expensive synchronizing.
/ Correct but possibly expensive multithreaded version
class Foo {
    private Helper helper;
    public synchronized Helper getHelper() {
        if (helper == null) {
            helper = new Helper();
        }
        return helper;
    }
    // other functions and members...
}
However, the first call to getHelper() will create the object and only the few threads trying to access it during that time need to be synchronized; after that all calls just get a reference to the member variable. Since synchronizing a method could in some extreme cases decrease performance by a factor of 100 or higher,[5] the overhead of acquiring and releasing a lock every time this method is called seems unnecessary: once the initialization has been completed, acquiring and releasing the locks would appear unnecessary. Many programmers have attempted to optimize this situation in the following manner:

Check that the variable is initialized (without obtaining the lock). If it is initialized, return it immediately.
Obtain the lock.
Double-check whether the variable has already been initialized: if another thread acquired the lock first, it may have already done the initialization. If so, return the initialized variable.
Otherwise, initialize and return the variable.
// Broken multithreaded version
// "Double-Checked Locking" idiom
class Foo {
    private Helper helper;
    public Helper getHelper() {
        if (helper == null) {
            synchronized(this) {
                if (helper == null) {
                    helper = new Helper();
                }
            }
        }
        return helper;
    }

    // other functions and members...
}
Intuitively, this algorithm seems like an efficient solution to the problem. However, this technique has many subtle problems and should usually be avoided. For example, consider the following sequence of events:

Thread A notices that the value is not initialized, so it obtains the lock and begins to initialize the value.
Due to the semantics of some programming languages, the code generated by the compiler is allowed to update the shared variable to point to a partially constructed object before A has finished performing the initialization. For example, in Java if a call to a constructor has been inlined then the shared variable may immediately be updated once the storage has been allocated but before the inlined constructor initializes the object.[6]
Thread B notices that the shared variable has been initialized (or so it appears), and returns its value. Because thread B believes the value is already initialized, it does not acquire the lock. If B uses the object before all of the initialization done by A is seen by B (either because A has not finished initializing it or because some of the initialized values in the object have not yet percolated to the memory B uses (cache coherence)), the program will likely crash.

As of J2SE 5.0, this problem has been fixed. The volatile keyword now ensures that multiple threads handle the singleton instance correctly.
// Works with acquire/release semantics for volatile in Java 1.5 and later
// Broken under Java 1.4 and earlier semantics for volatile
class Foo {
    private volatile Helper helper;
    public Helper getHelper() {
        Helper result = helper;
        if (result == null) {
            synchronized(this) {
                result = helper;
                if (result == null) {
                    helper = result = new Helper();
                }
            }
        }
        return result;
    }
    // other functions and members...
}
============================================
Heap vs stack:-
Java only stores primitives on the stack. This keeps the stack small and helps keeping individual stack frames small, thus allowing more nested calls.
Objects are created on the heap, and only references (which in turn are primitives) are passed around on the stack.

Threads:-
=========
When a CPU switches from executing one thread to executing another, the CPU needs to save the local data, program pointer etc. of the current thread, and load the local data, program pointer etc. of the next thread to execute. This switch is called a "context switch".
Concurrency - java.util.concurrent
Object - java.lang.Object
Persistent Data structure
if multiple threads point to the same persistent data structure and one thread modifies it, the modifying thread gets a reference to the new structure. All other threads keep a reference to the old structure which is still unchanged and thus consistent.
Actors vs channels:-
Workers are the actors and they can communicate with each other as messages in Actor model
In Channel model, the workers talk to each other through channels. They try to broadcast the message via channels
Same Threaded system: Data is not shared among the threads. Each thread has its own piece of data which is opposite to Multi Threaded system.

Thread communication happens by one of the Thread generates a message, which is copied by another thread which wants to read that message. The copying is done to ensure that the message is not updatable during read operation by Thread B.
Implementing Runnable is better than extending a thread, and handing an instance of the implementation to a Thread instance. When having the Runnable's executed by a thread pool it is easy to queue up the Runnable instances until a thread from the pool is idle.
Thread.currentThread() - The Thread.currentThread() method returns a reference to the Thread instance executing currentThread() . This way you can get access to the Java Thread object representing the thread executing a given block of code.

In a multithreaded environment,ArrayList and HashMap are not synchronized, while Vector and HashTable are. You should therefore use HashTable. HashTable will ensure that no other thread is working with the HashTable at any given time. If you use a HashMap, you'd have to do that manually by ensuring that you synchronize on HashMap before you call the method or Collections.synchronizedMap(new HashMap()).

Extends Thread or Implements Thread is better:-
extend Thread only when you are looking to modify run() and other methods as well. If you are simply looking to modify only the run() method implementing Runnable is the best option (Runnable interface has only one abstract method i.e. run() )

Race condition:-
affects the critical section of the system, which is the part of the logic where multiple thread can share the same object and can make an impact on the value of the object or the logic.Solution for the Race condition is to handle the critical section as an atomic instruction, so that only one thread is executing the block of code at a time.
Solution for Race condition: Using Synchronized block of code, locks, atomic variables(java.util.concurrent.atomic.AtomicInteger).

Local Objects and Local References to Object act differently in a thread.Here the reference is not shared but the referenced object is stored in heap and shared among threads.
Local Object- Thread safe
Local object reference - NO thread safe
Object member variable - Not Thread safe

All the class member variables and the object created by the threads are stored in the heap, including the object references(ocal variable may also be a reference to an object).In that case the reference (the local variable) is stored on the thread stack, but the object itself if stored on the heap.
Static class variables are also stored on the heap along with the class definition.

object lock and class lock:-
============================
Synchronized:-if more than one instance exist, then one thread at a time can execute inside a synchronized instance method per instance.
Static Synchronized: Synchronized static methods are synchronized on the class object of the class the synchronized static method belongs to. Since only one class object exists in the Java VM per class, only one thread can execute inside a static synchronized method in the same class.

volatile keyword: -

Wait(), Notify(), NotifyAll()- Tells about how threads communicate between each other.
=============================
A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object.In order to call either wait() or notify the calling thread must first obtain the lock on that object. In other words, the calling thread must call wait() or notify() from inside a synchronized block.
The waiting thread would call doWait(), and the notifying thread would call doNotify(). When a thread calls notify() on an object, one of the threads waiting on that object are awakened and allowed to execute. There is also a notifyAll() method that will wake all threads waiting on a given object.both the waiting and notifying thread calls wait() and notify() from within a synchronized block. A thread cannot call wait(), notify() or notifyAll() without holding the lock on the object the method is called on. If it does, an IllegalMonitorStateException is thrown.
Once a thread calls wait() it releases the lock it holds on the monitor object. This allows other threads to call wait() or notify() too, since these methods must be called from inside a synchronized block.
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block. In other words: The awakened thread must re-obtain the lock on the monitor object before it can exit the wait() call, because the wait call is nested inside a synchronized block. If multiple threads are awakened using notifyAll() only one awakened thread at a time can exit the wait() method, since each thread must obtain the lock on the monitor object in turn before exiting wait().

sleep():
	It is a static method on Thread class. It makes the current thread into the "Not Runnable" state for specified amount of time. During this time, the thread keeps the lock (monitors) it has acquired.

wait():
	It is a method on Object class. It makes the current thread into the "Not Runnable"	state. Wait is called on a object, not a thread. Before calling wait() method, the
	object should be synchronized, means the object should be inside synchronized block.	The call to wait() releases the acquired lock.
Suspend(), resume() and Destroy() has been deprecated.

Deadlock prevention:-
1). Lock ordering
2). Lock TimeOut
3). Deadlock Detection and then do lock timeout or assign priority to threads.

Starvation in Java:-
===================
Threads with high priority swallow all CPU time from threads with lower priority.
Threads are blocked indefinitely waiting to enter a synchronized block, because other threads are constantly allowed access before it.
Threads waiting on an object (called wait() on it) remain waiting indefinitely because other threads are constantly awakened instead of it.

use join() method to ensure all threads that started from main must end in order in which they started and also main should end in last.In other words waits for this thread to die. Calling join() method internally calls join(0);

ThreadLocal is a class which provides thread-local variables. Every thread has its own ThreadLocal value that makes ThreadLocal value threadsafe as well.
ThreadLocal is a generic class and can be used to store information like start timestamp of thread in that variable. Each thread has no visibility of the other thread.
Thread Dumps: analyzing threads performance, thread states, CPU consumed by threads, garbage collection including which all threads are daemon and not daemon.
Since values set on a ThreadLocal object only are visible to the thread who set the value, no thread can set an initial value on a ThreadLocal using set() which is visible to all threads.Instead you can specify an initial value for a ThreadLocal object by subclassing ThreadLocal and overriding the initialValue() method.

private ThreadLocal myThreadLocal = new ThreadLocal<String>() {
    @Override protected String initialValue() {
        return "This is the initial value";
    }
};
when program starts JVM creates  a ThreadGroup named main. Unless specified, all  newly created threads become members of the main thread group.ThreadGroup is initialized with default priority of 10.

Total JVM Memory --> Heap Memory + Non Heap
================
Heap Memory ---> Young Generation and Old Generation
Young Generation --> Eden And Survivor Space
Old Generation --> Tenured

Non Heap memory --> Perm Gen + reserved or virtual memory
permGen --> memory where metadat info of class and object is provided. replaced by metspace in java 8(flexible memory). Moved to native memory
Heap Memory java:
================
Heap is the primary storage inside JVM for storing the runtime data that are accessed by the multiple threads. Heap memory is the common for all the threads, the data stored in the heap is accessible to all the threads running on JVM.

Concurrency models:
Actors vs channels
Parallel vs Assembly line vs functional parallelism
Functional Parallelism: The basic idea of functional parallelism is that you implement your program using function calls. Functions can be seen as "agents" or "actors" that send messages to each other, just like in the assembly line concurrency model (AKA reactive or event driven systems). When one function calls another, that is similar to sending a message.
All parameters passed to the function are copied and then processing is done, hence there is no shared state which will lead to race conditions or any entity outside will be able to manipulate the data.All process works independently like the Atomic operation, where unit of works happens independently. This helps in executing each task written based on functional parallelism to be executed on different cpu's.
Functional parallelism : forkandjoinpool in java7 and Streams in java 8.

Single threaded vs multithreaded vs same threaded systems(messages are passed b/w the threads accessing different data)

Executor vs Thread:
==================
First and foremost difference between Thread and Executor is that java.lang.Thread is a class in Java while java.util.concurrent.Executor is an interface.
The Executor concept is actually an abstraction over parallel computation. It allows concurrent code to be run in managed way. On the other hand, Thread is a concrete way to run the code in parallel.
The third difference between an Executor and a Thread class is that former decouples a task (the code which needs to be executed in parallel) from execution, while in the case of a Thread, both task and execution are tightly coupled.
The Executor concept allows your task to be executed by a worker thread from the thread pool, while Thread itself execute your task.
The Executor concept allows your task is to be executed by a worker thread from the thread pool, while Thread itself execute your task.
Executor provides a execute() method which accepts a Runnable task, while Thread accepts the Runnable task on its constructor.
One more key difference between a Thread and an Executor is that a Thread can only execute one Runnable task but an Executor can execute any number of Runnable task.
In the case of Thread, the task is executed by the Thread which accepts Runnable instance, but in the case of Execution the command (a Runnable implementation) may be executed in a new thread, a pooled thread or in the calling thread itself, depending upon the implementation of Executor interface.
In the case of a thread, it's developer's responsibility to create and start the thread, but in the case of Executor, the framework will create and start threads for you. Though you can control the whole process by giving your implementation of Executor interface. Though, with the improvements in ForkJoinPool in Java 7 and 8, you might want to use that instead of Executor.

the Executor framework is that you can run concurrent tasks that may return a result after processing the task. The Java Concurrency API achieves this with the following two interfaces Callable and Future.
Callable : This interface has the call() method. In this method, you have to implement the logic of a task. The Callable interface is a parameterized interface, meaning you have to indicate the type of data the call() method will return.
Future : This interface has some methods to obtain the result generated by a Callable object and to manage its state.

Executor.submit() and execute()
A main difference between the submit() and execute() method is that ExecuterService.submit()can return result of computation because it has a return type of Future, but execute() method cannot return anything because it's return type is void.
The submit() can accept both Runnable and Callable task but execute() can only accept the Runnable task.
The submit() method is declared in ExecutorService interface while execute() method is declared in the Executor interface.



creating a thread in java leads to lot of memory overhead and hence better to reuse threads from threadpool.
Executor vs Thread: Executor service offers all the implementations of the Runnable interface, on top of that call() which is overridden can provide any object as return type alongwith exception where ever needed.
Executor interface has to create a threadpool using ExecutorService.newFixedThreadPool(size in integers).Use this executor to submit the task which is callable

      ExecutorService service = Executors.newFixedThreadPool(10);
      List<MyCallable> futureList = new ArrayList<MyCallable>();
      for ( int i=0; i<12; i++){
          MyCallable myCallable = new MyCallable((long)i);
          futureList.add(myCallable);
      }
Callable needs to implement call() method while a Runnable needs to implement run() method.
A Callable can return a value but a Runnable cannot.
A Callable can throw checked exception but a Runnable cannot.
A Callable can be used with ExecutorService#invokeXXX(Collection<? extends Callable<T>> tasks) methods but a Runnable cannot be.

RejectedExecutionHandler would be useful when you set max capacity for workQueue and number of tasks, which have been submitted to Executor are more than workQueue capacity.

Locks:-
with locks, you can release and acquire the locks in any order. - with synchronized, you can release the locks only in the order it was acquired.

Deadlock vs Nested Monitor Lockout:-
===================================
In deadlock, two threads are waiting for each other to release locks.In nested monitor lockout, Thread 1 is holding a lock A, and waits for a signal from Thread 2. Thread 2 needs the lock A to send the signal to Thread 1.

Slipped condition:
Slipped conditions means, that from the time a thread has checked a certain condition until it acts upon it, the condition has been changed by another thread so that it is erroneous for the first thread to act.


Threads:
Runnable
Future
Callable
run()
call()
Executor
Executors
ExecutorService
ThreadPoolExecutor
CountDownLatch
Queues & Topics
ForkJoinPool
Streams
